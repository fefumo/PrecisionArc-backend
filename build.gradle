import org.xml.sax.helpers.DefaultHandler
import org.gradle.api.GradleException
import javax.xml.parsers.DocumentBuilderFactory
import java.security.MessageDigest

plugins {
    id 'java'
    id 'war'
}

group = 'se.ifmo'
version = '1.0-SNAPSHOT'
/*
its better to use this:
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}
but i dont wanna install java 17 for it 
*/
sourceCompatibility = '17'
targetCompatibility = '17'

repositories {
    mavenCentral()
}

dependencies {
    // Jersey
    implementation 'org.glassfish.jersey.containers:jersey-container-servlet:3.0.0'
    implementation 'org.glassfish.jersey.inject:jersey-hk2:3.0.0'
    implementation 'org.glassfish.jersey.media:jersey-media-json-binding:3.0.0'

    // Jakarta EE
    providedCompile 'jakarta.platform:jakarta.jakartaee-api:10.0.0'
    providedCompile 'jakarta.ejb:jakarta.ejb-api:4.0.1'

    // Hibernate
    implementation 'org.hibernate.orm:hibernate-core:6.3.1.Final'

    // PostgreSQL
    implementation 'org.postgresql:postgresql:42.6.0'

    // Hashing
    implementation 'org.mindrot:jbcrypt:0.4'

    // JWT
    implementation 'io.jsonwebtoken:jjwt:0.9.1'

    // Logging
    implementation 'org.slf4j:slf4j-api:2.0.16'

    // javax.xml.parsers, org.w3c.dom
    implementation 'xml-apis:xml-apis:1.4.01'

    // Testing
    
    //Selenium
    testImplementation 'org.seleniumhq.selenium:selenium-java:4.19.1'
    
    //Junit
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-console-standalone:1.10.2'
    //testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    //implementation "org.junit.platform:junit-platform-console:1.9.2" // again, classpath problems
    //testImplementation 'org.apiguardian:apiguardian-api:1.1.2' // because of custom compile task
}

test{
    useJUnitPlatform()
}
ext.compileSucceeded = true

tasks.register('compile') {
    def srcDir = file('src/main/java')
    description = 'Compile .java files'
    group = 'CS lab'

    def outDir = file('build/classes/java/main')

    inputs.dir(srcDir)
    outputs.dir(outDir)

    doLast {
        try {
            outDir.mkdirs()
            def javaFiles = fileTree(srcDir).matching { include '**/*.java' }.files.collect { it.path }

            if (javaFiles.isEmpty()) {
                throw new GradleException("There are no .java files to compile")
            }

            def classpath = configurations.compileClasspath.files.join(File.pathSeparator)
            def command = ['javac', '-d', outDir.path]

            if (classpath) {
                command += ['-cp', classpath]
            }

            command += javaFiles

            println "Running: ${command.join(' ')}"
            def result = exec {
                commandLine command
                ignoreExitValue = true
            }

            copy {
                from 'src/main/resources'
                into 'build/resources/main'
            }

            if (result.exitValue == 0) {
                println "Compilation succeeded"
                compileSucceeded = true
            } else {
                println "Compilation failed"
                compileSucceeded = false
            }
        } catch (Exception e) {
            println "Error while the compile task: ${e.message}"
            buildSucceeded = false
        }

    }
}

// tasks.register('myWar') {
//     group = 'CS lab'
//     description = 'war compile'

//     dependsOn compile

//     doLast {
//         def warFile = file("build/libs/PrecisionArc.war")
//         def compiledClassesDir = file("build/classes/java/main")
//         def resourcesDir = file('src/main/resources/')

//         def warTmpDir = file("build/tmp/war")
//         def webInfDir = new File(warTmpDir, 'WEB-INF')
//         def libsDir = new File(webInfDir, 'lib')
//         def classesDir = new File(webInfDir, 'classes')

//         warFile.parentFile.mkdirs()
//         mkdir classesDir
//         mkdir libsDir

//         copy {
//             from compiledClassesDir
//             into classesDir
//         }

//         if (resourcesDir.exists()) {
//             copy {
//                 from resourcesDir
//                 into classesDir
//             }
//         }

//         exec {
//             workingDir warTmpDir
//             commandLine 'jar', 'cf', warFile.absolutePath, '.'
//         }

//         delete warTmpDir

//         println "WAR: ${warFile}"
//     }
// }

// No main class, this is just a class container
tasks.register('myBuild') {
    description = 'Package classes into a plain JAR (non-executable).'
    group = 'CS lab'

    dependsOn compile

    doLast {
        def jarFile = file('build/libs/OPILab3.jar')
        def classesFiles = file('build/classes')
        def manifest = file('build/tmp/jar/MANIFEST.MF')

        jarFile.parentFile.mkdirs()

        if (!manifest.exists()) {
            manifest.parentFile.mkdirs()
            manifest.text = "Manifest-Version: 1.0\n"
        }

        def command = [
                'jar', 'cmf', manifest.absolutePath, jarFile.absolutePath,
                '-C', classesFiles.absolutePath, '.'
        ]

        println "Executing ${command.join(' ')}"
        exec {
            commandLine command
        }
        println "JAR-file ${jarFile} has been successfully built"
    }
    // finalizedBy runTests
}

// tasks.register('buildJar') {
//     group = 'CS lab'
//     description = 'Package classes into a plain JAR.'

//     dependsOn 'compile'

//     doLast {
//         def jar = tasks.create('customJar', Jar) {
//             archiveBaseName.set('app')
//             archiveVersion.set(version)
//             from sourceSets.main.output
//             manifest {
//                 attributes(
//                     'Main-Class': 'se.ifmo.Main'
//                 )
//             }
//         }
//         jar.execute()
//     }
// }


tasks.register('myClean') {
    description = 'Remove \'build\' directory'
    group = 'CS lab'

    doLast {
        def buildDir = file('build')

        if (buildDir.exists()) {
            println "Removing ${buildDir} directory..."
            buildDir.deleteDir()
        } else {
            println '\'build\' directory not found'
        }
    }
}

tasks.register('xml') {
    description = 'Validates all project\'s .xml files'
    group = 'CS lab'

    doLast {
        def xmlFiles = fileTree('src/main/resources') {
            include '**/*.xml'
        }

        def factory = DocumentBuilderFactory.newInstance()
        factory.setValidating(false)

        def builder = factory.newDocumentBuilder()
        builder.setErrorHandler(new DefaultHandler())

        xmlFiles.each {
            try {
                builder.parse(it)
                println "File ${it} is valid"
            } catch (Exception e) {
                println "Error in file ${it}: ${e.message}"
            }
        }
    }
}
tasks.register('startBackend') {
    group = 'CS lab'
    description = 'Deploys WAR to WildFly'

    dependsOn tasks.war

    doLast {
        def wildflyHome = "${System.getProperty("user.home")}/wildfly/wildfly-preview-26.1.3.Final"
        def warFile = file("build/libs/PrecisionArc.war")
        def deployDir = file("$wildflyHome/standalone/deployments")
        def wildflyBin = file("$wildflyHome/bin/standalone.sh")

        if (!warFile.exists()) {
            throw new GradleException("WAR file not found: ${warFile}")
        }

        println "Copying ${warFile} to ${deployDir}"
        copy {
            from warFile
            into deployDir
        }

        println "Starting WildFly..."
        def pb = new ProcessBuilder("bash", "-c", "nohup ${wildflyBin.absolutePath} > wildfly.log 2>&1 &")
        pb.directory(file(wildflyHome))
        pb.start()
        println "WildFly started in background"

        println "Waiting for backend to be ready..."
        def maxAttempts = 30
        def backendReady = false

        for (int i = 0; i < maxAttempts; i++) {
            try {
                def conn = new URL("http://localhost:8080/").openConnection()
                conn.setConnectTimeout(1000)
                conn.setReadTimeout(1000)
                def code = conn.getResponseCode()
                println "Attempt $i: HTTP $code"
                if (code in [200, 400, 404, 405]) {
                    backendReady = true
                    println "Backend is ready!"
                    break
                }
            } catch (Exception e) {
                println "Attempt $i: Connection failed - ${e.message}"
            }
            sleep(1000)
        }

        if (!backendReady) {
            throw new GradleException("Backend did not become ready in time")
        }
    }
}


tasks.register('startFrontend') {
    group = 'CS lab'
    description = 'Starts React frontend using npm (background)'

    doLast {
        def frontendDir = "${System.getProperty('user.home')}/my-coding/PrecisionArc-frontend"

        println "Starting React frontend from $frontendDir..."

        exec {
            workingDir frontendDir
            commandLine 'bash', '-c', "nohup npm start > frontend.log 2>&1 &"
            ignoreExitValue = true
        }

        println "Frontend started in background (logs in frontend.log)"
    }
}
/* -------------------------------------- TESTING -------------------------------------- */

test {
    useJUnitPlatform()
}

def testSrcDir = 'src/test/java'
def testOutDir = 'build/classes/java/test'

tasks.register("compileTestClasses") {
    group = 'CS lab'
    description = 'Compiles JUnit test classes in src/test/java'


    inputs.dir(testSrcDir)
    outputs.dir(testOutDir)

    doLast {
        // def javaFiles = fileTree(testSrcDir).matching { include '**/*.java' }.files.collect { it.path }
        def srcFiles = fileTree(dir: testSrcDir, include: '**/*.java').files*.path

        if (srcFiles.isEmpty()) {
            println "No test sources to compile"
            return
        }

        def classpath = configurations.testRuntimeClasspath.asPath
        def command = ['javac', '-d', testOutDir, '-cp', classpath] + srcFiles

        println "Compiling test classes: ${command.join(' ')}"
        exec {
            commandLine command
        }
        println "Tests compiled successfully."
    }
}

tasks.register("runTests") {
    group = 'CS lab'
    description = 'build, deploy project & run tests'
    dependsOn compileTestClasses, war, startBackend, startFrontend 
    tasks.getByName('startBackend').mustRunAfter 'war'
    tasks.getByName('startFrontend').mustRunAfter 'startBackend'
    tasks.getByName('compileTestClasses').mustRunAfter 'startFrontend'

    doLast {
        println "Running functional tests..."

        def classpath = files(
                testOutDir,
                configurations.testRuntimeClasspath
        ).asPath


        def reportDir = "test-results"
        mkdir(reportDir)

        def cmd = [
                "java",
                "-cp", classpath,
                "org.junit.platform.console.ConsoleLauncher",
                "--scan-class-path", testOutDir,
                "--details", "tree",
                "--details-theme", "ascii",
                "--reports-dir=${reportDir}"
        ]

        def res = exec {
            commandLine cmd
            ignoreExitValue = true
        }

        if (res.exitValue == 0) {
            println "All tests passed!"
            file("build/test-success.flag").text = "success"
        }  else {
            println "Tests failed."
        }

        println "Tests run finished."
    }
    finalizedBy stopFrontend, stopBackend
}

tasks.register('stopFrontend') {
    group = 'CS lab'
    description = 'Stops the React frontend by killing processes named MainThread'

    doLast {
        println "Killing frontend processes with name MainThread..."
        exec {
            commandLine 'pkill', 'MainThread'
            ignoreExitValue = true
        }
        println "Frontend stop command issued (pkill MainThread)"
    }
}


tasks.register('stopBackend') {
    group = 'CS lab'
    description = 'Stops WildFly server'

    doLast {
        println "Stopping WildFly..."
        exec {
            commandLine 'pkill', '-f', 'wildfly.*standalone'
            ignoreExitValue = true
        }
        println "Killed wildfly"
    }
}

war {
    archiveFileName = 'PrecisionArc.war'
}


tasks.register('history') {
    group = 'CS lab'
    description = 'Finds the last working revision by sequentially checking previous versions until compilation succeeds'

    doLast {
        if (compileSucceeded) {
            println 'Compilation Succeeded. Task "history" skipped'
            return
        }

        println 'Compilation failed. Starting task "history"...'

        def maxAttempts = 50
        def attempt = 0

        def firstCommit = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-list', '--max-parents=0', 'HEAD'
            standardOutput = firstCommit
        }
        firstCommit = firstCommit.toString().trim()

        while (!compileSucceeded && attempt < maxAttempts) {
            attempt++
            println "Attempt #$attempt: Switching to previous commit..."

            def currentCommit = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'rev-parse', 'HEAD'
                standardOutput = currentCommit
            }
            currentCommit = currentCommit.toString().trim()

            if (currentCommit == firstCommit) {
                println "First commit reached. Making diff.txt file..."

                def allCommits = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-list', '--reverse', '--all'
                    standardOutput = allCommits
                    ignoreExitValue true
                }
                def commitList = allCommits.toString().trim().split("\n")

                if (commitList.size() > 1) {
                    def secondCommit = commitList[1] // Head~2

                    def diffOutput = new ByteArrayOutputStream()
                    exec {
                        commandLine 'git', 'diff', currentCommit, secondCommit
                        standardOutput = diffOutput
                        ignoreExitValue true
                    }

                    def diffFile = file("build/diff.txt")
                    diffFile.parentFile.mkdirs()
                    exec {
                        commandLine 'git', 'diff', currentCommit, secondCommit
                        standardOutput = new FileOutputStream(diffFile)
                        ignoreExitValue true
                    }
                    println "Diff now in: ${diffFile.absolutePath}"
                    compileSucceeded = true

                } else {
                    println "There is no next commit"
                }

                break
            }

            exec {
                commandLine 'git', 'checkout', 'HEAD^'
            }

            println "Trying to compile..."

            def src = file('src/main/java/se/ifmo')
            def outDir = file('build/classes/java/main')
            outDir.mkdirs()
            def javaFiles = fileTree(src).matching { include '**/*.java' }.files.collect { it.path }

            if (javaFiles.isEmpty()) {
                throw new GradleException("There are no .java files to compile")
            }

            def classpath = configurations.compileClasspath.files.join(File.pathSeparator)
            def command = ['javac', '-d', outDir.path]

            if (classpath) {
                command += ['-cp', classpath]
            }

            command += javaFiles

            def result = exec {
                commandLine command
                ignoreExitValue = true
            }

            if (result.exitValue == 0) {
                println "Compile Success! Making diff.txt ..."

                def successCommit = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-parse', 'HEAD'
                    standardOutput = successCommit
                }
                successCommit = successCommit.toString().trim()

                def allCommitsFromSuccess = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-list', '--reverse', 'HEAD..main'
                    standardOutput = allCommitsFromSuccess
                    ignoreExitValue true
                }
                def commitList = allCommitsFromSuccess.toString().trim().split("\n")

                def secondCommit = commitList[0] // HEAD^

                def diffFile = file("build/diff.txt")
                diffFile.parentFile.mkdirs()
                exec {
                    commandLine 'git', 'diff', successCommit, secondCommit
                    standardOutput = new FileOutputStream(diffFile)
                    ignoreExitValue true
                }
                println "Diff now in: ${diffFile.absolutePath}"
                compileSucceeded = true

                break

            } else {
                println "Compilation still failed."
            }
        }

        if (!compileSucceeded) {
            throw new GradleException("Unable to build project on any revision")
        }
        exec {
            commandLine 'git', 'checkout', 'main'
        }
    }
}
